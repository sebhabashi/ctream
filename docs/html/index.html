<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ctream: Ctream: Container streams for C++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ctream
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Containers streams for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Ctream: Container streams for C++ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
What is Ctream ?</h1>
<p>Ctream is a single-header library that provides fast parallelized pipelines on STL containers (vector, list etc.) and emulates the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Java Stream API</a> syntax.</p>
<p>Ctream's main advantage is its simplicity, its speed, and its clear syntax (especially for developpers that are used to Java). Because it is a single header, it can be integrated into your project with great simplicity, either installed in your system includes, or added directly to your project.</p>
<p>Ctream enables you to write code like this: </p><div class="fragment"><div class="line"><span class="comment">// Use Ctream to get the maximum of the input integers</span></div>
<div class="line"><span class="keyword">auto</span> max = <a class="code" href="group__ctream.html#ga3aeb2067c3db7cfa8a27fec73caa5fb8">ctream::toCtream</a>(argv, argc)</div>
<div class="line">        .map&lt;std::string&gt;()</div>
<div class="line">        .filter(validInteger)</div>
<div class="line">        .map&lt;<span class="keywordtype">long</span>&gt;([] (<span class="keyword">const</span> std::string&amp; str) { <span class="keywordflow">return</span> std::stol(str); })</div>
<div class="line">        .max();</div>
<div class="ttc" id="agroup__ctream_html_ga3aeb2067c3db7cfa8a27fec73caa5fb8"><div class="ttname"><a href="group__ctream.html#ga3aeb2067c3db7cfa8a27fec73caa5fb8">ctream::toCtream</a></div><div class="ttdeci">internal::Ctream&lt; T &gt; toCtream(const std::vector&lt; T &gt; &amp;vec)</div><div class="ttdoc">Stream a vector.</div><div class="ttdef"><b>Definition:</b> ctream.hpp:952</div></div>
</div><!-- fragment --><p> In this example we:</p><ul>
<li>Create a Ctream pipeline from <code>int argc</code> et <code>char** argv</code></li>
<li>Cast each <code>char*</code> element to <code>std::string</code> using the <code>std::string</code> constructor</li>
<li>Filter only the elements for which <code>bool validInteger(const std::string&amp;)</code> returns <code>true</code></li>
<li>Parse each element as an integer using <code>std::stol</code></li>
<li>Compute the maximum of the elements</li>
</ul>
<p>All that effortlessly!</p>
<h1><a class="anchor" id="autotoc_md2"></a>
How to get it ?</h1>
<p>Tagged releases will be available soon in the Releases section. In the meantime, you can simply download the file <code><a class="el" href="ctream_8hpp_source.html">include/ctream.hpp</a></code> and add it into your project.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
How to use it ?</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
Compatibility</h2>
<p>Ctream is compatible with C++11 and higher.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Caution</h2>
<p>Ctream objects represent manipulation pipelines, not containers. Using Ctream objects after their data source is destroyed will result in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Basic usage and examples</h2>
<h3><a class="anchor" id="autotoc_md7"></a>
Examples</h3>
<p>Get the sum of the even numbers </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sum = ctream::toCtream&lt;int&gt;(...)</div>
<div class="line">        .filter([] (<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; })</div>
<div class="line">        .sum();</div>
</div><!-- fragment --><p> Get the age of the oldest person </p><div class="fragment"><div class="line"><span class="keyword">auto</span> max = ctream::toCtream&lt;Person&gt;(...)</div>
<div class="line">        .extract&lt;<span class="keywordtype">int</span>&gt;([] (<span class="keyword">const</span> Person&amp; p) { <span class="keywordflow">return</span> p.age; })</div>
<div class="line">        .max();</div>
</div><!-- fragment --><p> Convert a list into a vector </p><div class="fragment"><div class="line"><span class="keyword">auto</span> list = std::list&lt;int&gt;(...);</div>
<div class="line"><span class="keyword">auto</span> vect = <a class="code" href="group__ctream.html#ga3aeb2067c3db7cfa8a27fec73caa5fb8">ctream::toCtream</a>(list).toVector();</div>
</div><!-- fragment --><p> Square all values in a vector </p><div class="fragment"><div class="line"><span class="keyword">auto</span> values = std::vector&lt;double&gt;(...);</div>
<div class="line"><span class="keyword">auto</span> squares = <a class="code" href="group__ctream.html#ga3aeb2067c3db7cfa8a27fec73caa5fb8">ctream::toCtream</a>(values)</div>
<div class="line">        .map&lt;<span class="keywordtype">double</span>&gt;([] (<span class="keywordtype">double</span> v) { <span class="keywordflow">return</span> v * v; });</div>
<div class="line">        .toVector();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
Creating a stream from a container</h3>
<p>Ctream's can be constructed from different container types: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; vec(...);</div>
<div class="line"><span class="keyword">auto</span> vectorStream = <a class="code" href="group__ctream.html#ga3aeb2067c3db7cfa8a27fec73caa5fb8">ctream::toCtream</a>(vec);</div>
<div class="line"> </div>
<div class="line">std::list&lt;int&gt; list(...);</div>
<div class="line"><span class="keyword">auto</span> listStream = <a class="code" href="group__ctream.html#ga3aeb2067c3db7cfa8a27fec73caa5fb8">ctream::toCtream</a>(list);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> raw[ARRAY_SIZE] = {...};</div>
<div class="line"><span class="keyword">auto</span> rawStream = <a class="code" href="group__ctream.html#ga3aeb2067c3db7cfa8a27fec73caa5fb8">ctream::toCtream</a>(raw, ARRAY_SIZE);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md9"></a>
Filtering</h3>
<p>To keep only certain elements of the stream, use <code>filter</code>. </p><div class="fragment"><div class="line"><span class="comment">// Filter only the even/odd numbers of a stream</span></div>
<div class="line"><span class="keyword">auto</span> numbers = ctream::toCtream&lt;int&gt;(...);</div>
<div class="line"><span class="keyword">auto</span> evenNumbers = numbers.filter([] (<span class="keywordtype">int</span> i) {</div>
<div class="line">    <span class="keywordflow">return</span> i % 2 == 0;</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> oddNumbers = numbers.filter([] (<span class="keywordtype">int</span> i) {</div>
<div class="line">    <span class="keywordflow">return</span> i % 2 == 1;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Filter only the strings that are not empty</span></div>
<div class="line"><span class="keyword">auto</span> strings = ctream::toCtream&lt;std::string&gt;(...);</div>
<div class="line"><span class="keyword">auto</span> notEmptyStrings = strings.filter([] (<span class="keyword">const</span> std::string&amp; s) {</div>
<div class="line">    <span class="keywordflow">return</span> !s.empty();</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
Extracting data</h3>
<p>To transform the data using only const references to data within the elements, use <code>extract</code>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Person</div>
<div class="line">{</div>
<div class="line">    std::string firstName;</div>
<div class="line">    std::string lastName;</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line">    std::string address;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> persons = ctream::toCtream&lt;Person&gt;(...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract the age of every person</span></div>
<div class="line"><span class="keyword">auto</span> ages = persons.extract&lt;<span class="keywordtype">int</span>&gt;([] (<span class="keyword">const</span> Person&amp; p) {</div>
<div class="line">    <span class="keywordflow">return</span> p.age;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract the first name of every person</span></div>
<div class="line"><span class="keyword">auto</span> firstNames = persons.extract&lt;std::string&gt;([] (<span class="keyword">const</span> Person&amp; p) {</div>
<div class="line">    <span class="keywordflow">return</span> p.firstName;</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Transforming (mapping) the elements</h3>
<p>When interesting data is not directly present in the elements and has to be constructed, <code>extract</code> cannot be used. In this case, we use <code>map</code>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Person</div>
<div class="line">{</div>
<div class="line">    std::string firstName;</div>
<div class="line">    std::string lastName;</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line">    std::string address;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> persons = ctream::toCtream&lt;Person&gt;(...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get a stream containing the full name of every person</span></div>
<div class="line"><span class="keyword">auto</span> names = persons.map&lt;std::string&gt;([] (<span class="keyword">const</span> Person&amp; p) {</div>
<div class="line">    <span class="keywordflow">return</span> p.firstName + <span class="stringliteral">&quot; &quot;</span> + p.lastName;</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
Converting back to usable data</h3>
<p>The data of the stream can be exported back to STL containers using <code>toList</code> or <code>toVector</code>. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> stream = ctream::toCtream&lt;int&gt;(...);</div>
<div class="line">std::list&lt;int&gt; list = stream.toList();</div>
<div class="line">std::vector&lt;int&gt; vect = stream.toVector();</div>
</div><!-- fragment --><p> It can also be reduced with common operations: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> stream = ctream::toCtream&lt;int&gt;(...);</div>
<div class="line"><span class="keyword">auto</span> sum = stream.sum(); <span class="comment">// Compute the sum</span></div>
<div class="line"><span class="keyword">auto</span> prod = stream.product(); <span class="comment">// Compute the product</span></div>
<div class="line"><span class="keyword">auto</span> min = stream.min(); <span class="comment">// Get the minimum</span></div>
<div class="line"><span class="keyword">auto</span> max = stream.max(); <span class="comment">// Get the maximum</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> strings = ctream::toCtream&lt;std::string&gt;(...);</div>
<div class="line"><span class="keyword">auto</span> concat = strings.concat(); <span class="comment">// Concatenates all strings</span></div>
</div><!-- fragment --><p> For other operations, it is necessary to use Collectors.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Using Collectors</h3>
<p>Collectors are the way data is exported from a stream. In fact, all previous exporters are just shorthands for Collectors: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> stream = ctream::toCtream&lt;int&gt;(...);</div>
<div class="line">std::list&lt;int&gt; list = stream.collect(collectors::ToList&lt;int&gt;{});</div>
<div class="line">std::vector&lt;int&gt; vect = stream.collect(collectors::ToVector&lt;int&gt;{});</div>
<div class="line"><span class="keyword">auto</span> sum = stream.collect(collectors::Sum&lt;int&gt;{});</div>
<div class="line"><span class="keyword">auto</span> prod = stream.collect(collectors::Product&lt;int&gt;{});</div>
<div class="line"><span class="keyword">auto</span> min = stream.collect(collectors::Min&lt;int&gt;{});</div>
<div class="line"><span class="keyword">auto</span> max = stream.collect(collectors::Max&lt;int&gt;{});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> strings = ctream::toCtream&lt;std::string&gt;(...);</div>
<div class="line"><span class="keyword">auto</span> concat = strings.collect(collectors::Concat&lt;std::string&gt;{});</div>
</div><!-- fragment --><p> To create specific collectors, the templated interface <code>Collector&lt;T, A, R&gt;</code> must be implemented with:</p><ul>
<li>T being the input type</li>
<li>A being the accumulator type (see below, often the same as R)</li>
<li>R being the result type</li>
</ul>
<p>Collectors are objects that contain information on how to export the data from the streams into usable output data. Their aim is to have a simple syntax, and to be parallelized easily.</p>
<p>The logic behind collectors is to <code>accumulate()</code> the elements of type T of the stream in to partial results of type A. These partial results are then combined into a complete result of type A with function <code>combine()</code>. This complete result is finally converted into the final output result of type R by function <code>finish()</code>.</p>
<p>Using a different type for A and R is not always necessary, but it can sometimes be very useful. For instance, to concatenate strings, a solution to avoid copying strings endlessly (the one used in this library) is to use stringstream objects as accumulators, and then finish by extracting the string from the stringstream.</p>
<p>For instance, the <code>Sum</code> collector, where A and R are identical, is defined as follows: </p><div class="fragment"><div class="line"><span class="comment">// Sum up all the elements of the stream</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>Sum : <span class="keyword">public</span> Collector&lt;T, T, T&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    T supply()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> 0; }</div>
<div class="line">    <span class="keywordtype">void</span> accumulate(T&amp; a, <span class="keyword">const</span> T&amp; b)<span class="keyword"> const override </span>{ a += b; };</div>
<div class="line">    <span class="keywordtype">void</span> combine(T&amp; a, T&amp; b)<span class="keyword"> const override </span>{ a += b; };</div>
<div class="line">    T finish(T&amp; a)<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> a; }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Alternatively, the <code>Concat</code> collector uses different types for A (stringstream) and R (string): </p><div class="fragment"><div class="line"><span class="comment">// Concatenate the elements of the stream into a string</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>Concat : <span class="keyword">public</span> Collector&lt;T, std::stringstream, std::string&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::stringstream supply()<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::stringstream{};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> accumulate(std::stringstream&amp; a, <span class="keyword">const</span> T&amp; b)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        a &lt;&lt; b;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> combine(std::stringstream&amp; a, std::stringstream&amp; b)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        a &lt;&lt; b.str();</div>
<div class="line">    }</div>
<div class="line">    std::string finish(std::stringstream&amp; a)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> a.str();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Collectors can be "implemented" inline using the <code>Custom</code> collector: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> intSumCollector = collector::Custom&lt;int, int, int&gt;(</div>
<div class="line">        [] () { <span class="keywordflow">return</span> 0; }, <span class="comment">// supplier</span></div>
<div class="line">        [] (<span class="keywordtype">int</span>&amp; a, <span class="keywordtype">int</span> b) { a+= b }, <span class="comment">// accumulator</span></div>
<div class="line">        [] (<span class="keywordtype">int</span>&amp; a, <span class="keywordtype">int</span>&amp; b) { a+= b }, <span class="comment">// combiner</span></div>
<div class="line">        [] (<span class="keywordtype">int</span> a) { <span class="keywordflow">return</span> a; }); <span class="comment">// finisher</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> sum = ctream::toCtream&lt;int&gt;(...).collect(intSumCollector);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14"></a>
Examples</h1>
<p>Examples are available in directory <code>examples</code>, and more should come.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
API documentation</h1>
<p>Complete documentation can be found in the <code>docs</code> directory, and can be regenerated using Doxygen. Interesting entry points can be:</p><ul>
<li>The <a href="https://htmlpreview.github.io/?https://github.com/sebhabashi/ctream/blob/main/docs/html/group__ctream.html">CStream class documentation</a> (<code>ctream::Ctream&lt;T&gt;</code>)</li>
<li>The <a href="https://htmlpreview.github.io/?https://github.com/sebhabashi/ctream/blob/main/docs/html/group__collectors.html">Collector API</a> (<code>ctream::collectors</code>) </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
